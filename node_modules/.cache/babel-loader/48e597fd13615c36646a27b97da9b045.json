{"ast":null,"code":"import { __assign, __spreadArray } from 'tslib';\nimport { Observable, pipe } from 'rxjs';\nimport { map, startWith, pairwise, filter, scan, distinctUntilChanged } from 'rxjs/operators';\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar DEFAULT_OPTIONS = {\n  includeMetadataChanges: false\n};\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nfunction _fromRef(ref, options) {\n  if (options === void 0) {\n    options = DEFAULT_OPTIONS;\n  }\n  /* eslint-enable @typescript-eslint/no-explicit-any */\n\n\n  return new Observable(function (subscriber) {\n    var unsubscribe = ref.onSnapshot(options, {\n      next: subscriber.next.bind(subscriber),\n      error: subscriber.error.bind(subscriber),\n      complete: subscriber.complete.bind(subscriber)\n    });\n    return {\n      unsubscribe: unsubscribe\n    };\n  });\n}\n\nfunction fromRef(ref, options) {\n  return _fromRef(ref, options);\n}\n\nfunction fromDocRef(ref, options) {\n  return fromRef(ref, options);\n}\n\nfunction fromCollectionRef(ref, options) {\n  return fromRef(ref, options);\n}\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nfunction doc(ref) {\n  return fromDocRef(ref, {\n    includeMetadataChanges: true\n  });\n}\n/**\n * Returns a stream of a document, mapped to its data payload and optionally the document ID\n * @param query\n */\n\n\nfunction docData(ref, idField) {\n  return doc(ref).pipe(map(function (snap) {\n    return snapToData(snap, idField);\n  }));\n}\n\nfunction snapToData(snapshot, idField) {\n  var _a; // match the behavior of the JS SDK when the snapshot doesn't exist\n\n\n  if (!snapshot.exists) {\n    return snapshot.data();\n  }\n\n  return __assign(__assign({}, snapshot.data()), idField ? (_a = {}, _a[idField] = snapshot.id, _a) : null);\n}\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar ALL_EVENTS = ['added', 'modified', 'removed'];\n/**\n * Create an operator that determines if a the stream of document changes\n * are specified by the event filter. If the document change type is not\n * in specified events array, it will not be emitted.\n */\n\nvar filterEvents = function (events) {\n  return filter(function (changes) {\n    var hasChange = false;\n\n    for (var i = 0; i < changes.length; i++) {\n      var change = changes[i];\n\n      if (events && events.indexOf(change.type) >= 0) {\n        hasChange = true;\n        break;\n      }\n    }\n\n    return hasChange;\n  });\n};\n/**\n * Splice arguments on top of a sliced array, to break top-level ===\n * this is useful for change-detection\n */\n\n\nfunction sliceAndSplice(original, start, deleteCount) {\n  var args = [];\n\n  for (var _i = 3; _i < arguments.length; _i++) {\n    args[_i - 3] = arguments[_i];\n  }\n\n  var returnArray = original.slice();\n  returnArray.splice.apply(returnArray, __spreadArray([start, deleteCount], args));\n  return returnArray;\n}\n/**\n * Creates a new sorted array from a new change.\n * @param combined\n * @param change\n */\n\n\nfunction processIndividualChange(combined, change) {\n  switch (change.type) {\n    case 'added':\n      if (combined[change.newIndex] && combined[change.newIndex].doc.ref.isEqual(change.doc.ref)) ;else {\n        return sliceAndSplice(combined, change.newIndex, 0, change);\n      }\n      break;\n\n    case 'modified':\n      if (combined[change.oldIndex] == null || combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n        // When an item changes position we first remove it\n        // and then add it's new position\n        if (change.oldIndex !== change.newIndex) {\n          var copiedArray = combined.slice();\n          copiedArray.splice(change.oldIndex, 1);\n          copiedArray.splice(change.newIndex, 0, change);\n          return copiedArray;\n        } else {\n          return sliceAndSplice(combined, change.newIndex, 1, change);\n        }\n      }\n\n      break;\n\n    case 'removed':\n      if (combined[change.oldIndex] && combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n        return sliceAndSplice(combined, change.oldIndex, 1);\n      }\n\n      break;\n  }\n\n  return combined;\n}\n/**\n * Combines the total result set from the current set of changes from an incoming set\n * of changes.\n * @param current\n * @param changes\n * @param events\n */\n\n\nfunction processDocumentChanges(current, changes, events) {\n  if (events === void 0) {\n    events = ALL_EVENTS;\n  }\n\n  changes.forEach(function (change) {\n    // skip unwanted change types\n    if (events.indexOf(change.type) > -1) {\n      current = processIndividualChange(current, change);\n    }\n  });\n  return current;\n}\n/**\n * Create an operator that allows you to compare the current emission with\n * the prior, even on first emission (where prior is undefined).\n */\n\n\nvar windowwise = function () {\n  return pipe(startWith(undefined), pairwise());\n};\n/**\n * Given two snapshots does their metadata match?\n * @param a\n * @param b\n */\n\n\nvar metaDataEquals = function (a, b) {\n  return JSON.stringify(a.metadata) === JSON.stringify(b.metadata);\n};\n/**\n * Create an operator that filters out empty changes. We provide the\n * ability to filter on events, which means all changes can be filtered out.\n * This creates an empty array and would be incorrect to emit.\n */\n\n\nvar filterEmptyUnlessFirst = function () {\n  return pipe(windowwise(), filter(function (_a) {\n    var prior = _a[0],\n        current = _a[1];\n    return current.length > 0 || prior === undefined;\n  }), map(function (_a) {\n    _a[0];\n    var current = _a[1];\n    return current;\n  }));\n};\n/**\n * Return a stream of document changes on a query. These results are not in sort order but in\n * order of occurence.\n * @param query\n */\n\n\nfunction collectionChanges(query, events) {\n  if (events === void 0) {\n    events = ALL_EVENTS;\n  }\n\n  return fromCollectionRef(query, {\n    includeMetadataChanges: true\n  }).pipe(windowwise(), map(function (_a) {\n    var priorSnapshot = _a[0],\n        currentSnapshot = _a[1];\n    var docChanges = currentSnapshot.docChanges();\n\n    if (priorSnapshot && !metaDataEquals(priorSnapshot, currentSnapshot)) {\n      // the metadata has changed, docChanges() doesn't return metadata events, so let's\n      // do it ourselves by scanning over all the docs and seeing if the metadata has changed\n      // since either this docChanges() emission or the prior snapshot\n      currentSnapshot.docs.forEach(function (currentDocSnapshot, currentIndex) {\n        var currentDocChange = docChanges.find(function (c) {\n          return c.doc.ref.isEqual(currentDocSnapshot.ref);\n        });\n\n        if (currentDocChange) {\n          // if the doc is in the current changes and the metadata hasn't changed this doc\n          if (metaDataEquals(currentDocChange.doc, currentDocSnapshot)) {\n            return;\n          }\n        } else {\n          // if there is a prior doc and the metadata hasn't changed skip this doc\n          var priorDocSnapshot = priorSnapshot === null || priorSnapshot === void 0 ? void 0 : priorSnapshot.docs.find(function (d) {\n            return d.ref.isEqual(currentDocSnapshot.ref);\n          });\n\n          if (priorDocSnapshot && metaDataEquals(priorDocSnapshot, currentDocSnapshot)) {\n            return;\n          }\n        }\n\n        docChanges.push({\n          oldIndex: currentIndex,\n          newIndex: currentIndex,\n          type: 'modified',\n          doc: currentDocSnapshot\n        });\n      });\n    }\n\n    return docChanges;\n  }), filterEvents(events), filterEmptyUnlessFirst());\n}\n/**\n * Return a stream of document snapshots on a query. These results are in sort order.\n * @param query\n */\n\n\nfunction collection(query) {\n  return fromCollectionRef(query, {\n    includeMetadataChanges: true\n  }).pipe(map(function (changes) {\n    return changes.docs;\n  }));\n}\n/**\n * Return a stream of document changes on a query. These results are in sort order.\n * @param query\n */\n\n\nfunction sortedChanges(query, events) {\n  return collectionChanges(query, events).pipe(scan(function (current, changes) {\n    return processDocumentChanges(current, changes, events);\n  }, []), distinctUntilChanged());\n}\n/**\n * Create a stream of changes as they occur it time. This method is similar\n * to docChanges() but it collects each event in an array over time.\n */\n\n\nfunction auditTrail(query, events) {\n  return collectionChanges(query, events).pipe(scan(function (current, action) {\n    return __spreadArray(__spreadArray([], current), action);\n  }, []));\n}\n/**\n * Returns a stream of documents mapped to their data payload, and optionally the document ID\n * @param query\n */\n\n\nfunction collectionData(query, idField) {\n  return collection(query).pipe(map(function (arr) {\n    return arr.map(function (snap) {\n      return snapToData(snap, idField);\n    });\n  }));\n}\n\nexport { auditTrail, collection, collectionChanges, collectionData, doc, docData, fromCollectionRef, fromDocRef, fromRef, snapToData, sortedChanges };","map":{"version":3,"mappings":"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","names":["DEFAULT_OPTIONS","includeMetadataChanges","_fromRef","ref","options","Observable","subscriber","unsubscribe","onSnapshot","next","bind","error","complete","fromRef","fromDocRef","fromCollectionRef","doc","docData","idField","pipe","map","snap","snapToData","snapshot","_a","exists","data","__assign","id","ALL_EVENTS","filterEvents","events","filter","changes","hasChange","i","length","change","indexOf","type","sliceAndSplice","original","start","deleteCount","args","_i","arguments","returnArray","slice","splice","apply","__spreadArray","processIndividualChange","combined","newIndex","isEqual","oldIndex","copiedArray","processDocumentChanges","current","forEach","windowwise","startWith","undefined","pairwise","metaDataEquals","a","b","JSON","stringify","metadata","filterEmptyUnlessFirst","prior","collectionChanges","query","priorSnapshot","currentSnapshot","docChanges","docs","currentDocSnapshot","currentIndex","currentDocChange","find","c","priorDocSnapshot","d","push","collection","sortedChanges","scan","distinctUntilChanged","auditTrail","action","collectionData","arr"],"sources":["../../firestore/fromRef.ts","../../firestore/document/index.ts","../../firestore/collection/index.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Observable } from 'rxjs';\nvar DEFAULT_OPTIONS = { includeMetadataChanges: false };\n/* eslint-disable @typescript-eslint/no-explicit-any */\nfunction _fromRef(ref, options) {\n    if (options === void 0) { options = DEFAULT_OPTIONS; }\n    /* eslint-enable @typescript-eslint/no-explicit-any */\n    return new Observable(function (subscriber) {\n        var unsubscribe = ref.onSnapshot(options, {\n            next: subscriber.next.bind(subscriber),\n            error: subscriber.error.bind(subscriber),\n            complete: subscriber.complete.bind(subscriber),\n        });\n        return { unsubscribe: unsubscribe };\n    });\n}\nexport function fromRef(ref, options) {\n    return _fromRef(ref, options);\n}\nexport function fromDocRef(ref, options) {\n    return fromRef(ref, options);\n}\nexport function fromCollectionRef(ref, options) {\n    return fromRef(ref, options);\n}\n","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign } from \"tslib\";\nimport { fromDocRef } from '../fromRef';\nimport { map } from 'rxjs/operators';\nexport function doc(ref) {\n    return fromDocRef(ref, { includeMetadataChanges: true });\n}\n/**\n * Returns a stream of a document, mapped to its data payload and optionally the document ID\n * @param query\n */\nexport function docData(ref, idField) {\n    return doc(ref).pipe(map(function (snap) { return snapToData(snap, idField); }));\n}\nexport function snapToData(snapshot, idField) {\n    var _a;\n    // match the behavior of the JS SDK when the snapshot doesn't exist\n    if (!snapshot.exists) {\n        return snapshot.data();\n    }\n    return __assign(__assign({}, snapshot.data()), (idField ? (_a = {}, _a[idField] = snapshot.id, _a) : null));\n}\n","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __spreadArray } from \"tslib\";\nimport { fromCollectionRef } from '../fromRef';\nimport { pipe } from 'rxjs';\nimport { map, filter, scan, distinctUntilChanged, startWith, pairwise } from 'rxjs/operators';\nimport { snapToData } from '../document';\nvar ALL_EVENTS = ['added', 'modified', 'removed'];\n/**\n * Create an operator that determines if a the stream of document changes\n * are specified by the event filter. If the document change type is not\n * in specified events array, it will not be emitted.\n */\nvar filterEvents = function (events) {\n    return filter(function (changes) {\n        var hasChange = false;\n        for (var i = 0; i < changes.length; i++) {\n            var change = changes[i];\n            if (events && events.indexOf(change.type) >= 0) {\n                hasChange = true;\n                break;\n            }\n        }\n        return hasChange;\n    });\n};\n/**\n * Splice arguments on top of a sliced array, to break top-level ===\n * this is useful for change-detection\n */\nfunction sliceAndSplice(original, start, deleteCount) {\n    var args = [];\n    for (var _i = 3; _i < arguments.length; _i++) {\n        args[_i - 3] = arguments[_i];\n    }\n    var returnArray = original.slice();\n    returnArray.splice.apply(returnArray, __spreadArray([start, deleteCount], args));\n    return returnArray;\n}\n/**\n * Creates a new sorted array from a new change.\n * @param combined\n * @param change\n */\nfunction processIndividualChange(combined, change) {\n    switch (change.type) {\n        case 'added':\n            if (combined[change.newIndex] &&\n                combined[change.newIndex].doc.ref.isEqual(change.doc.ref)) {\n                // Skip duplicate emissions. This is rare.\n                // TODO: Investigate possible bug in SDK.\n            }\n            else {\n                return sliceAndSplice(combined, change.newIndex, 0, change);\n            }\n            break;\n        case 'modified':\n            if (combined[change.oldIndex] == null ||\n                combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n                // When an item changes position we first remove it\n                // and then add it's new position\n                if (change.oldIndex !== change.newIndex) {\n                    var copiedArray = combined.slice();\n                    copiedArray.splice(change.oldIndex, 1);\n                    copiedArray.splice(change.newIndex, 0, change);\n                    return copiedArray;\n                }\n                else {\n                    return sliceAndSplice(combined, change.newIndex, 1, change);\n                }\n            }\n            break;\n        case 'removed':\n            if (combined[change.oldIndex] &&\n                combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n                return sliceAndSplice(combined, change.oldIndex, 1);\n            }\n            break;\n        default: // ignore\n    }\n    return combined;\n}\n/**\n * Combines the total result set from the current set of changes from an incoming set\n * of changes.\n * @param current\n * @param changes\n * @param events\n */\nfunction processDocumentChanges(current, changes, events) {\n    if (events === void 0) { events = ALL_EVENTS; }\n    changes.forEach(function (change) {\n        // skip unwanted change types\n        if (events.indexOf(change.type) > -1) {\n            current = processIndividualChange(current, change);\n        }\n    });\n    return current;\n}\n/**\n * Create an operator that allows you to compare the current emission with\n * the prior, even on first emission (where prior is undefined).\n */\nvar windowwise = function () {\n    return pipe(startWith(undefined), pairwise());\n};\n/**\n * Given two snapshots does their metadata match?\n * @param a\n * @param b\n */\nvar metaDataEquals = function (a, b) { return JSON.stringify(a.metadata) === JSON.stringify(b.metadata); };\n/**\n * Create an operator that filters out empty changes. We provide the\n * ability to filter on events, which means all changes can be filtered out.\n * This creates an empty array and would be incorrect to emit.\n */\nvar filterEmptyUnlessFirst = function () {\n    return pipe(windowwise(), filter(function (_a) {\n        var prior = _a[0], current = _a[1];\n        return current.length > 0 || prior === undefined;\n    }), map(function (_a) {\n        var _ = _a[0], current = _a[1];\n        return current;\n    }));\n};\n/**\n * Return a stream of document changes on a query. These results are not in sort order but in\n * order of occurence.\n * @param query\n */\nexport function collectionChanges(query, events) {\n    if (events === void 0) { events = ALL_EVENTS; }\n    return fromCollectionRef(query, { includeMetadataChanges: true }).pipe(windowwise(), map(function (_a) {\n        var priorSnapshot = _a[0], currentSnapshot = _a[1];\n        var docChanges = currentSnapshot.docChanges();\n        if (priorSnapshot && !metaDataEquals(priorSnapshot, currentSnapshot)) {\n            // the metadata has changed, docChanges() doesn't return metadata events, so let's\n            // do it ourselves by scanning over all the docs and seeing if the metadata has changed\n            // since either this docChanges() emission or the prior snapshot\n            currentSnapshot.docs.forEach(function (currentDocSnapshot, currentIndex) {\n                var currentDocChange = docChanges.find(function (c) {\n                    return c.doc.ref.isEqual(currentDocSnapshot.ref);\n                });\n                if (currentDocChange) {\n                    // if the doc is in the current changes and the metadata hasn't changed this doc\n                    if (metaDataEquals(currentDocChange.doc, currentDocSnapshot)) {\n                        return;\n                    }\n                }\n                else {\n                    // if there is a prior doc and the metadata hasn't changed skip this doc\n                    var priorDocSnapshot = priorSnapshot === null || priorSnapshot === void 0 ? void 0 : priorSnapshot.docs.find(function (d) {\n                        return d.ref.isEqual(currentDocSnapshot.ref);\n                    });\n                    if (priorDocSnapshot &&\n                        metaDataEquals(priorDocSnapshot, currentDocSnapshot)) {\n                        return;\n                    }\n                }\n                docChanges.push({\n                    oldIndex: currentIndex,\n                    newIndex: currentIndex,\n                    type: 'modified',\n                    doc: currentDocSnapshot\n                });\n            });\n        }\n        return docChanges;\n    }), filterEvents(events), filterEmptyUnlessFirst());\n}\n/**\n * Return a stream of document snapshots on a query. These results are in sort order.\n * @param query\n */\nexport function collection(query) {\n    return fromCollectionRef(query, { includeMetadataChanges: true }).pipe(map(function (changes) { return changes.docs; }));\n}\n/**\n * Return a stream of document changes on a query. These results are in sort order.\n * @param query\n */\nexport function sortedChanges(query, events) {\n    return collectionChanges(query, events).pipe(scan(function (current, changes) {\n        return processDocumentChanges(current, changes, events);\n    }, []), distinctUntilChanged());\n}\n/**\n * Create a stream of changes as they occur it time. This method is similar\n * to docChanges() but it collects each event in an array over time.\n */\nexport function auditTrail(query, events) {\n    return collectionChanges(query, events).pipe(scan(function (current, action) { return __spreadArray(__spreadArray([], current), action); }, []));\n}\n/**\n * Returns a stream of documents mapped to their data payload, and optionally the document ID\n * @param query\n */\nexport function collectionData(query, idField) {\n    return collection(query).pipe(map(function (arr) {\n        return arr.map(function (snap) { return snapToData(snap, idField); });\n    }));\n}\n"]},"metadata":{},"sourceType":"module"}